https://stackoverflow.com/questions/31870170
Obviously, the correct answer is 'benchmark it and find out', but in the spirit of the internet, I'm hoping someone will have done the work for me.
I really like Guava's cache libraries for web services. Their docs are fairly vague on this point, however.

<API label="com.google.common.cache.CacheBuilder.recordStats">recordStats</API>
<code>public CacheBuilder <API label="com.google.common.cache.CacheBuilder.recordStats">recordStats</API>()</code>
Enable the accumulation of <a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheStats.html" rel="nofollow noreferrer"><code>CacheStats</code></a> during the operation of the cache. Without this <code><API label="com.google.common.cache.Cache.stats">Cache.stats</API>()</code> will return zero for all statistics. Note that recording <API label="">stats</API> requires bookkeeping to be performed with each operation, and thus imposes a performance penalty on cache operation.
Since:
12.0 (previously, <API label="">stats</API> collection was automatic)

From JavaDocs for <a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#<API label="">recordStats</API>%28%29" rel="nofollow noreferrer"><code><API label="com.google.common.cache.CacheBuilder.recordStats">CacheBuilder.recordStats</API>()</code></a>.
I'm curious if the severity of the performance penalty is documented, benchmarked or ball-parked by anyone. I'm thinking it should be pretty minor, on the order of nanoseconds per operation. The cache operations themselves are already synchronized - reads don't lock or block, but writes do acquire locks - so no additional locking or concurrency should be required to modify the <API label="">stats</API>. That should <API label="">limit</API> it to a few additional <API label="">increment</API> operations per cache access.
The other side of it is perhaps some penalty when <code><API label="com.google.common.cache.Cache.stats">Cache.stats</API>()</code> is called. I'm planning on exposing the <API label="">stats</API> to persistent recording through Codahale MetricsRegistry and onto a Graphite server. The net effect is that the <API label="">stats</API> will be retrieved periodically, so if there's any blocking behavior on retrieval, that could be bad.

==========
Lets take a look at the <a href="https://github.com/google/guava/tree/a34e7053d0b1db281893e0ec430f0d27ffa8e85e/guava/src/com/google/common/cache" rel="noreferrer">source code</a>:

What happens when we call <code><API label="com.google.common.cache.CacheBuilder.recordStats">CacheBuilder.recordStats</API>()</code>?

<a href="https://github.com/google/guava/blob/a34e7053d0b1db281893e0ec430f0d27ffa8e85e/guava/src/com/google/common/cache/CacheBuilder.java" rel="noreferrer"><code>CacheBuilder</code></a> defines a no-op <a href="https://github.com/google/guava/blob/a34e7053d0b1db281893e0ec430f0d27ffa8e85e/guava/src/com/google/common/cache/AbstractCache.java#L137" rel="noreferrer"><code>StatsCounter</code></a> implementation <a href="https://github.com/google/guava/blob/a34e7053d0b1db281893e0ec430f0d27ffa8e85e/guava/src/com/google/common/cache/CacheBuilder.java#L158" rel="noreferrer"><code>NULL_STATS_COUNTER</code></a> and this is what is used by default.  If you call <code>.<API label="com.google.common.cache.CacheBuilder.recordStats">recordStats</API>()</code> this is replaced with <a href="https://github.com/google/guava/blob/a34e7053d0b1db281893e0ec430f0d27ffa8e85e/guava/src/com/google/common/cache/AbstractCache.java#L199" rel="noreferrer"><code>SimpleStatsCounter</code></a> which has six <a href="https://github.com/google/guava/blob/a34e7053d0b1db281893e0ec430f0d27ffa8e85e/guava/src/com/google/common/cache/LongAddable.java" rel="noreferrer"><code>LongAddable</code></a> fields (which is usually a <a href="https://github.com/google/guava/blob/a34e7053d0b1db281893e0ec430f0d27ffa8e85e/guava/src/com/google/common/cache/LongAdder.java" rel="noreferrer"><code>LongAdder</code></a> but falls back to an <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicLong.html" rel="noreferrer"><code>AtomicLong</code></a> if it can't use <code>LongAdder</code>) for each of the statistics it tracks.

Then what happens when we construct a <code>Cache</code>?

For a standard <a href="https://github.com/google/guava/blob/a34e7053d0b1db281893e0ec430f0d27ffa8e85e/guava/src/com/google/common/cache/LocalCache.java" rel="noreferrer"><code>LocalCache</code></a> (which is what you get from <code><API label="com.google.common.cache.CacheBuilder.build">CacheBuilder.build</API>()</code> or <code><API label="com.google.common.cache.CacheBuilder.build">CacheBuilder.build</API>(CacheLoader)</code>), it constructs an instance of the desired <code>StatsCounter</code> <a href="https://github.com/google/guava/blob/a34e7053d0b1db281893e0ec430f0d27ffa8e85e/guava/src/com/google/common/cache/LocalCache.java#L262" rel="noreferrer">during construction</a>.  Each <a href="https://github.com/google/guava/blob/a34e7053d0b1db281893e0ec430f0d27ffa8e85e/guava/src/com/google/common/cache/LocalCache.java#L1974" rel="noreferrer"><code>Segment</code></a> of the <code>Cache</code> similarly gets <a href="https://github.com/google/guava/blob/a34e7053d0b1db281893e0ec430f0d27ffa8e85e/guava/src/com/google/common/cache/LocalCache.java#L311" rel="noreferrer">its own instance</a> of the same <code>StatsCounter</code> type.  Other <code>Cache</code> implementations can choose to use a <code>SimpleStatsCounter</code> if they desire, or provide their own behavior (e.g. a no-op implementation).

And when we use the <code>Cache</code>?

Every call into <code>LocalCache</code> that would impact one of the statistics calls the relevant <code>StatsCounter.record*()</code> methods, which in turn causes an atomic <API label="">increment</API> or addition on the backing <code>LongAddable</code>.  <code>LongAdder</code> is documented to be significantly faster than <code>AtomicLong</code>, so like you say this should be hardly noticeable.  Though in the case of the no-op <code>StatsRecorder</code> the JIT could optimize away the <code>record*()</code> calls entirely, which could maybe be noticeable over time.  But deciding not to track statistics on that basis would surely be <a href="http://c2.com/cgi/wiki?PrematureOptimization" rel="noreferrer">premature optimization</a>.

And finally when we get the statistics?

When you call <a href="https://github.com/google/guava/blob/a34e7053d0b1db281893e0ec430f0d27ffa8e85e/guava/src/com/google/common/cache/LocalCache.java#L4840" rel="noreferrer"><code><API label="com.google.common.cache.Cache.stats">Cache.stats</API>()</code></a> the <code>StatsCounter</code>s for the <code>Cache</code> and all its <code>Segments</code> are <a href="https://github.com/google/guava/blob/a34e7053d0b1db281893e0ec430f0d27ffa8e85e/guava/src/com/google/common/cache/AbstractCache.java#L261" rel="noreferrer">aggregated together</a> in a new <code>StatsCounter</code> and the result returned to you.  This means there will be minimal blocking; each field only needs to be read once, and there's no external synchronizing or locking.  This does <API label="">mean</API> there's technically a race condition (a segment could be accessed midway through the aggregation) but in practice that's irrelevant.

So in summary?

You should feel comfortable using <code><API label="com.google.common.cache.CacheBuilder.recordStats">CacheBuilder.recordStats</API>()</code> on any <code>Cache</code> you're interested in monitoring, and calling <code><API label="com.google.common.cache.Cache.stats">Cache.stats</API>()</code> as frequently as is beneficial.  The memory overhead is roughly <API label="">constant</API>, the speed overhead is negligible (and faster than any similar monitoring you could likely implement), as is the contention overhead of <code><API label="com.google.common.cache.Cache.stats">Cache.stats</API>()</code>.

Obviously a dedicated thread doing nothing but calling <code><API label="com.google.common.cache.Cache.stats">Cache.stats</API>()</code> in a loop will cause some contention, but that would be silly.  Any <API label="">sort</API> of periodic access will go unnoticed.

